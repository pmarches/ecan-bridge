#!/bin/env python3
import socket
import binascii
import struct
import argparse
from enum import Enum
import yaml
import tomlkit
import datetime
import can
from logging import debug,info,warn,error
import logging
import time
import os
import select

ECAN_CLIENT_UDP_PORT=1902
ECAN_GATEWAY_UDP_PORT=1901
ECAN_GATEWAY_CAN1_TCP_PORT=8881
ECAN_GATEWAY_CAN2_TCP_PORT=8882

class GatewayCANConfig:
    def totoml(self):
        canTable = tomlkit.table()
        canTable.add('mystery1', str(binascii.hexlify(self.mystery1)))
        canTable.add('remoteIp', self.remoteIp)
        canTable.add('remotePort', self.remotePort)
        canTable.add('localPort', self.localPort)
        canTable.add('mystery2', str(binascii.hexlify(self.mystery2)))
        canTable.add('mystery3', str(binascii.hexlify(self.mystery3)))
        canTable.add('registrationMessage', self.registrationMessage)
        canTable.add('keepAliveMessage', self.keepAliveMessage)
        return canTable

class GatewayConfiguration:
    def __init__(self):
        self.can1=GatewayCANConfig()
        self.can2=GatewayCANConfig()

    def totoml(self):
        doc = tomlkit.document()
        doc.add(tomlkit.comment("ECAN-E01 Configuration file in TOML format. Generated by the command: <CMD HERE>"))
        doc.add(tomlkit.nl())
        doc.add('mystery0', str(binascii.hexlify(self.mystery0)))
        doc.add(tomlkit.nl())

        doc.add('macadress', self.macadress)
        doc['macadress'].comment("Read only")

        doc['serialNumber']=self.serialNumber
        doc['serialNumber'].comment("Read only")

        doc['firmwareVersion']=self.firmwareVersion
        doc['firmwareVersion'].comment("Read only")

        doc.add('devicemodel', self.deviceModel)
        doc['devicemodel'].comment("Read only")
        doc.add(tomlkit.nl())
        
        doc.add('deviceName', self.deviceName)
        doc.add('localStaticIp', self.localStaticIp)
        doc.add('gateway', self.gateway)
        doc.add('netmask', self.netmask)
        doc.add('dns', self.dns)
        
        doc.add(tomlkit.nl())
        doc.add(tomlkit.comment("This section relates to the behaviour when the gateway first starts."))
        doc.add('reportCycle', self.reportCycle)
        doc.add('reportTargetIp', self.reportTargetIp)
        doc.add('reportTargetPort', self.reportTargetPort)
        doc.add('reconnectionTimeout', self.reconnectionTimeout)
        doc.add('noCANDataAutoReboot', self.noCANDataAutoReboot)
        doc['noCANDataAutoReboot'].comment("Number of seconds without CANBus traffic for device to reboot")

        doc.add('can1', self.can1.totoml())
        doc.add('can2', self.can2.totoml())

        return tomlkit.dumps(doc)

def parseMacAddressFromGateway(dataFromGateway):
    debug('RX %s : %s',binascii.hexlify(dataFromGateway))
    (magic,action)=struct.unpack('BB', dataFromGateway[0:2])
    if(magic==0xFD and action==0x06):
        (macbytes,mystery)=struct.unpack('6s2s', dataFromGateway[2:])
        return macbytes
    return None

def getBasicInfoFromGateway(udpSocket, deviceIpAndPort):
    QUERY_PAYLOAD=b'www.cdebyte.comwww.cdebyte.com' #Magic bytes that trigger a response
    udpSocket.sendto(QUERY_PAYLOAD, deviceIpAndPort)

    data, ipAndPort = udpSocket.recvfrom(1024)
    macAddress=parseMacAddressFromGateway(data)
    return (ipAndPort[0], macAddress)

def discoverECanGateways(interfaceName):
    debug('Searching for ECAN-E01 gateway on device %s', interfaceName)
    udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    udpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    udpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_BINDTODEVICE, bytes(interfaceName, 'ascii'))
    udpSocket.bind(('<broadcast>', ECAN_CLIENT_UDP_PORT))
    udpSocket.settimeout(3)
    #udpSocket.connect(('<broadcast>', ECAN_GATEWAY_UDP_PORT))
    ipAndMac=getBasicInfoFromGateway(udpSocket, ('<broadcast>', ECAN_GATEWAY_UDP_PORT))
    udpSocket.close()

    return ipAndMac

def connectToGatewayByIp(deviceIpAddr):
    udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    udpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    udpSocket.bind(('<broadcast>', ECAN_CLIENT_UDP_PORT))
    udpSocket.settimeout(3)
    return udpSocket;

def resolveMacAddress(deviceIpAddr):
    udpSocket = connectToGatewayByIp(deviceIpAddr)
    deviceIpAndPort=(deviceIpAddr, ECAN_GATEWAY_UDP_PORT)
    (_,deviceMacAddress) = getBasicInfoFromGateway(udpSocket, deviceIpAndPort)
    return (udpSocket,deviceIpAndPort, deviceMacAddress)

class ProprietaryConfigFileReader:
    MAINCONFIG_BYTES_SIZE=240
    CANCHANNEL_BYTE_SIZE=424
    
    def ipBytesToStr(ipBytes):
        return socket.inet_ntoa(ipBytes)
    
    def parseConfigurationZero(responseBytes, config):
        debug('responseBytes %s', binascii.hexlify(responseBytes))

        parts=struct.unpack('2s32s11sBBBBBB11s26s4s4s4s4sB129sHHH', responseBytes)
        config.mystery0=parts[0]
        config.deviceModel=parts[1].decode('ascii').rstrip('\x00')
        config.firmwareVersion=parts[2].decode('ascii').rstrip('\x00')
        config.macadress='%02X:%02X:%02X:%02X:%02X:%02X' % parts[3:9]
        config.deviceName=parts[9].decode('ascii').rstrip('\x00')
        config.serialNumber=parts[10].decode('ascii').rstrip('\x00')

        config.localStaticIp=ProprietaryConfigFileReader.ipBytesToStr(parts[11])
        config.gateway=ProprietaryConfigFileReader.ipBytesToStr(parts[12])
        config.netmask=ProprietaryConfigFileReader.ipBytesToStr(parts[13])
        config.dns=ProprietaryConfigFileReader.ipBytesToStr(parts[14])

        config.reportCycle=parts[15]
        config.reportTargetIp=parts[16].decode('ascii').rstrip('\x00')
        config.reportTargetPort=parts[17]
        config.reconnectionTimeout=parts[18]
        config.noCANDataAutoReboot=parts[19]

    def parseConfigurationCANChannel(configurationCANChannelBytes, canConfig):
        debug('configurationCANChannelBytes %s', binascii.hexlify(configurationCANChannelBytes))
        parts=struct.unpack('12s128s4sII6s134s132s', configurationCANChannelBytes)
        canConfig.mystery1=parts[0]
        canConfig.remoteIp=parts[1].decode('ascii').rstrip('\x00')
        canConfig.mystery2=parts[2]
        canConfig.remotePort=parts[3]
        canConfig.localPort=parts[4]
        canConfig.mystery3=parts[5]
        canConfig.registrationMessage=parts[6].decode('ascii').rstrip('\x00')
        canConfig.keepAliveMessage=parts[7].decode('ascii').rstrip('\x00')
    
    
    def parseConfigurationFile(inputfilepath):
        with open(inputfilepath, mode='rb') as inputfile:
            fmt='>II'
            filemagic1,filemagic2=struct.unpack(fmt, inputfile.read(struct.calcsize(fmt)))
            if(filemagic1!=0x09 or filemagic2!=0xF2):
                raise Exception('Unknown file format')
            
            config=GatewayConfiguration()
            ProprietaryConfigFileReader.parseConfigurationZero(inputfile.read(ProprietaryConfigFileReader.MAINCONFIG_BYTES_SIZE), config)
            inputfile.read(6) #Unknown, in file only
            ProprietaryConfigFileReader.parseConfigurationCANChannel(inputfile.read(ProprietaryConfigFileReader.CANCHANNEL_BYTE_SIZE), config.can1)
            inputfile.read(6) #Unknown, in file only
            ProprietaryConfigFileReader.parseConfigurationCANChannel(inputfile.read(ProprietaryConfigFileReader.CANCHANNEL_BYTE_SIZE), config.can2)
            return config


def getConfigurationPage(udpSocket, deviceMacAddress, deviceIpAndPort, configurationPage):
    debug('Reading device configuration page %d', configurationPage)
    getBasicConfigurationCmd=bytearray(b'\xfe\x00')
    getBasicConfigurationCmd.extend(deviceMacAddress)
    getBasicConfigurationCmd.extend(struct.pack('>H', configurationPage))
    udpSocket.sendto(getBasicConfigurationCmd, deviceIpAndPort)

    responseBytes, addr = udpSocket.recvfrom(1024)
    magic, action, macAddress, configurationSection=struct.unpack('BB6s2s', responseBytes[0:10])
    configBytes=responseBytes[10:]
    debug('Got %d bytes of config data', len(configBytes))
    return configBytes;

def readConfiguration(deviceIpAddr):
    (udpSocket,deviceIpAndPort, deviceMacAddress)=resolveMacAddress(deviceIpAddr)
    configuration0Bytes=getConfigurationPage(udpSocket, deviceMacAddress, deviceIpAndPort, 0)
    config=GatewayConfiguration()
    ProprietaryConfigFileReader.parseConfigurationZero(configuration0Bytes[2:], config)

    configuration1Bytes=getConfigurationPage(udpSocket, deviceMacAddress, deviceIpAndPort, 1)
    ProprietaryConfigFileReader.parseConfigurationCANChannel(configuration1Bytes[2:], config.can1)

    configuration2Bytes=getConfigurationPage(udpSocket, deviceMacAddress, deviceIpAndPort, 2)
    ProprietaryConfigFileReader.parseConfigurationCANChannel(configuration2Bytes[2:], config.can2)

    udpSocket.close()
    return config

def rebootGateway(deviceIpAddr):
    (udpSocket,deviceIpAndPort, deviceMacAddress)=resolveMacAddress(deviceIpAddr)
    
    rebootCmd=bytearray(b'\xfe\x03')
    rebootCmd.extend(deviceMacAddress)
    info('Rebooting %s',deviceIpAddr);
    udpSocket.sendto(rebootCmd, deviceIpAndPort)
    rebootResponse, addr = udpSocket.recvfrom(1024)
    #debug('RX', addr, ' ',binascii.hexlify(rebootResponse))
    
    expectedRebootResponse=bytearray(b'\xfd\x03')
    expectedRebootResponse.extend(deviceMacAddress)
    expectedRebootResponse.extend(b'\x09\x00')
    if rebootResponse!=expectedRebootResponse:
        error('Unexpected reboot response', binascii.hexlify(rebootResponse))
    info('Received the reboot confirmation from gateway')
    udpSocket.close()
    info('Upon startup, the gateway will attempt to grap a DHCP address, if it fails to do so, it will fallback to the static IP 192.168.4.101')

def convertCANBusFrameToGatewayFormat(CANBusFrame):
    flagbyte=0
    flagbyte|=0b10000000 if(CANBusFrame.is_extended_id) else 0
    flagbyte|=0b01000000 if(CANBusFrame.is_remote_frame) else 0
    flagbyte|=0b00001111 & CANBusFrame.dlc

    proprietaryFormat=bytearray()
    proprietaryFormat.extend(flagbyte.to_bytes(1, 'big'))
    proprietaryFormat.extend(CANBusFrame.arbitration_id.to_bytes(4, 'big'))
    proprietaryFormat.extend(CANBusFrame.data.ljust(8, b'\0'))
    debug("Conversion to Proprietary format yields: %s", proprietaryFormat.hex())
    return proprietaryFormat
    #return b'\x88\x12\x34\x56\x78\x11\x22\x33\x44\x55\x66\x77\x88'

def convertGatewayFormatToCANBusFrame(gatewayFormatBytes):
    is_extended_id=gatewayFormatBytes[0] & 0b10000000
    payloadLen=gatewayFormatBytes[0] & 0b00001111
    debug("gatewayFormatBytes[0]=%d payloadLen=%d", gatewayFormatBytes[0], payloadLen)
    arbitration_id=int.from_bytes(gatewayFormatBytes[1:5], 'big')
    msg=can.Message(is_extended_id=is_extended_id, arbitration_id=arbitration_id,data=gatewayFormatBytes[5:5+payloadLen])
    debug("gateway format to canbus yields message: %s", msg)
    return msg

def doBridge(channelName, gatewayAddress, gatewayPort):
    info("Starting bridge on virtual can device %s and gateway %s port %d", channelName, gatewayAddress, gatewayPort)
    
    sockettogateway=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sockettogateway.settimeout(10)
    sockettogateway.connect((gatewayAddress, gatewayPort))
    sockettogateway.setblocking(False)
    
    bus = can.interface.Bus(bustype='socketcan', channel=channelName)
    while(True):
        try:
            DATA_FRAME_LEN=13
            gatewayFormatFrame=sockettogateway.recv(DATA_FRAME_LEN)
            debug("Got a data frame from the gateway: %s", str(binascii.hexlify(gatewayFormatFrame)))
            msg=convertGatewayFormatToCANBusFrame(gatewayFormatFrame)
            bus.send(msg)
        except BlockingIOError:
            debug("No data to read on the IP socket side")
            #debug("Waiting for some IO event")
            #select.select([bus,sockettogateway], [bus,sockettogateway], []) 
        
        CANBusFrame=bus.recv(0.01)
        if(CANBusFrame is None):
            debug("No data to read on the canbus side")
        else:
            debug("Got %s from canbus", CANBusFrame)
            gatewayCompatibleBytes=convertCANBusFrameToGatewayFormat(CANBusFrame)
            sockettogateway.send(gatewayCompatibleBytes)
        
    bus.shutdown()
    sockettogateway.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
                    prog='ecane01-cli',
                    description='CLI app to the ECAN-E01 CANBus over ethernet gateway.\nEXAMPLE: ./ecane01-cli.py bridge -i 192.168.4.101 -p 8881 -c vcan0',
                    epilog='Use at your own risk')
    parser.add_argument('-n', '--netinterface',  help='Network interface to search for the CANBus gateway')
    parser.add_argument('-c', '--canbus',  default='vcan0', help='The CANBus interface to use locally Default: vcan0')
    parser.add_argument('-i', '--ipaddress', help='IP address of the CANBus gateway')
    parser.add_argument('-p', '--port', type=int, default=ECAN_GATEWAY_CAN1_TCP_PORT, help='TCP port of the CANBus gateway')
    parser.add_argument('-f', '--inputfile', help='TOML Configuration file to be used as input')
    parser.add_argument('-v', '--verbose', action='count', default=0, help='Verbose output')
    parser.add_argument('action', choices=['scan','reboot','readconf','writeconf','bridge'])
    args = parser.parse_args()
    if(args.verbose==0):
        logging.basicConfig(level=logging.ERROR)
    elif(args.verbose==1):
        logging.basicConfig(level=logging.INFO)
    else:
        logging.basicConfig(level=logging.DEBUG)

    debug(args)
    
    if args.action=='scan':
        if args.netinterface is None:
            error("ERROR: scan requires the -n argument with one of these network interface: %s" % str(os.listdir('/sys/class/net/')))
            exit(1)
        else:
            (ip,mac)=discoverECanGateways(args.netinterface)
            if ip:
                print("{}\t{}".format(mac.hex(':'),ip))
            else:
                error('Gateway not found')
                exit(1)
    elif args.action=='readconf':
        if(args.inputfile):
            print(ProprietaryConfigFileReader.parseConfigurationFile(args.inputfile).totoml())
        elif(args.ipaddress):
            print(readConfiguration(args.ipaddress).totoml())
        else:
            error("You must specify either the -f or -a flag for this action")
            exit(1)
    elif args.action=='writeconf':
        error("Not implemented yet")
        exit(1)
    elif args.action=='reboot':
        rebootGateway(args.ipaddress)
    elif args.action=='bridge':
        if(args.ipaddress and args.port):
            doBridge(args.canbus, args.ipaddress, args.port)
        else:
            error("You must specify the gateway address with the -i flag and its port with the -p flag")
            exit(1)
        
